@use 'sass:color' as color;
@use 'sass:string' as string;
@use 'sass:list' as list;
@use 'sass:map' as map;

@use 'variables' as *;
@use 'typography' as typography;
@use 'meta' as meta;

/// Function that find last index of substring
///
/// @param { string } string
/// @param { string } substring
/// @return { number } last index
@function string-last-index($string, $substring) {
    $index: string.index($string, $substring);
    $result: $index;
    @if $index {
        $string-length: string.length($string);
        $substring-length: string.length($substring);
        @for $i from $index + $substring-length through $string-length {
            $substring-length: string.length($substring);
            @if str-slice($string, $i, $i + $substring-length - 1) == $substring {
                $result: $i;
            }
        }
    }
    @return $result;
}

/// Browser context in px
$BROWSER_CONTEXT: 16px;

/// Converter px to root em values
///
/// @param { number | px } px
/// @return { em } em root units
@function em($pixels, $context: $BROWSER_CONTEXT) {
    @if (unitless($pixels)) {
        $pixels: $pixels * 1px;
    }

    @if (unitless($context)) {
        $context: $context * 1px;
    }

    @return calc($pixels / $context) * 1em;
}

/// Body font in px
$BODY_FONT: 16px;

/// Converter px to rem values
///
/// @param { number | px } px
/// @return { rem } rem units
@function rem($pixels) {
    @if (unitless($pixels)) {
        $pixels: $pixels * 1px;
    }

    @return calc($pixels / $BODY_FONT) * 1rem;
}

/// Converts list of px to list of rems
///
/// @param { px[] } list of px
/// @return { rem[] } list of rems
@function list-rem($list) {
    $result: ();
    @each $value in $list {
        $result: list.append($result, #{rem($value)});
    }
    @return $result;
}

/// Formatter for css var name
///
/// @param { string } prefix prefix for var
/// @param { string } name css var name
///
/// @return { string } css var name with prefix
@function css-var-name($prefix, $name) {
    @return --#{$prefix}-#{$name};
}

/// Converter color to `RRR GGG BBB` color format
///
/// @param { color } color
/// @return { string } color formatted in `RRR GGG BBB`
@function color-to-css-var($color) {
    @if (type-of($color) != 'color') {
        @error 'param must be color type'
    }

    $red: color.red($color);
    $green: color.green($color);
    $blue: color.blue($color);

    @return #{#{$red} #{$green} #{$blue}};
}

/// Checker is valid breakpoint
///
/// @param { string } breakpoint name
/// @return { true } if breakpoint valid else throw error
@function validate-breakpoint($breakpoint) {
    @if (map-has-key($breakpoints, $breakpoint)) {
        @return true;
    } @else {
        @error 'Undefined "#{$breakpoint}" breakpoint. Allowed: #{map-keys($breakpoints)}.';
    }
}

/// Mixin for apply rules only from breakpoint
///
/// @param { string } breakpoint name
@mixin from-breakpoint($breakpoint) {
    $isValid: validate-breakpoint($breakpoint);

    $breakpoint-start: map-get($breakpoints, $breakpoint);

    @media (min-width: em($breakpoint-start)) {
        @content;
    }
}

/// Mixin for apply rules only between breakpoints
///
/// @param { string } breakpoint-start first breakpoint name
/// @param { string } breakpoint-end second breakpoint name
@mixin between-breakpoint($breakpoint-start, $breakpoint-end) {
    $isValid: validate-breakpoint($breakpoint-start);
    $isValid: validate-breakpoint($breakpoint-end);

    @include from-breakpoint($breakpoint-start) {
        @include until-breakpoint($breakpoint-end) {
            @content;
        }
    }
}

/// Mixin for apply rules only until breakpoint
///
/// @param { string } breakpoint name
@mixin until-breakpoint($breakpoint) {
    $isValid: validate-breakpoint($breakpoint);

    $previous-breakpoint-end: map-get($breakpoints, $breakpoint);

    @media (max-width: em($previous-breakpoint-end - 0.5px)) {
        @content;
    }
}

/// Validatior for typography names
///
/// @param { string } typography name
/// @return { true } if valid typography else throws error
@function validate-typography($typography) {
    @if (map-has-key(typography.$typography, $typography)) {
        @return true;
    } @else {
        @error 'Unknown "#{$typography}" typography. Allowed typography: #{map-keys(typography.$typography)}.';
    }
}

/// Mixin for apply typography
///
/// @param { string } typo name of typography
@mixin typo($typo) {
    $isValid: validate-typography($typo);

    $font-weight-key: str-slice($typo, string-last-index($typo, '-') + 1);
    $font-weight-css-var: '--#{map.get(meta.$prefixes, font-weight)}-#{$font-weight-key}';

    $font-size-key: str-slice($typo, 0, string-last-index($typo, '-') - 1);
    $font-size-css-var: '--#{map.get(meta.$prefixes, font-size)}-#{$font-size-key}';

    font-weight: var(#{$font-weight-css-var});
    font-size: var(#{$font-size-css-var});
}
